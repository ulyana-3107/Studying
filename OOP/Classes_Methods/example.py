# Класс можно воспринимать как некое пространство имен, в котором записаны свойства и методы - все это и есть атрибуты
# класса. И далее когда мы создаем экземпляры класса, все эти атрибуты остаются в классе и не копируются в отдельные эк
# земпляры -> атрибуты класса являются общими для всех его экземпляров, но при этом с помощью экземпляров можно обращать
# ся к атрибутам, так как пространство имен объектов содержит ссылку на внешнее пространство имен, и если какой-либо ат
# рибут не существует в экземпляре, то поиск идет во внешнем пространстве


class Example:

    external_value = 25

    def __init__(self, elem):
        self.value = elem

    @classmethod
    def set_value(cls, new_elem):
        Example.external_value = new_elem


# obj = Example('lol')
# print(obj.external_value)
# obj.set_value('value1')
# print(obj.value, obj.external_value)


# class Point:
#     color = 'red'
#
#     def set_coords(self):
#         print(f'coordinates are set for {str(self)}.')
#
#     # мы можем устанавливать координаты для различных экземпляров классов с помощью методов
#     def set_coords1(self, x, y):
#         self.x, self.y = x, y
#
#     # так-же можно и получать значения тех или иных координат
#     def get_coords(self):
#         return self.x, self.y
#
# # имя метода set_point - это атрибут класса Point, и мы можем обратиться к нему:
# print(Point.set_coords)
# # когда мы вызываем методы экземпляров, то интерпретатор автоматически подставляет первым параметром self - который явля
# # ется ссылкой на экземпляр класса. те с помощью параметра self можно указать, какой экземпляр использует данную функцию
# p1, p2 = Point(), Point()
# p1.set_coords()
# p2.set_coords()
# # как видно, self дает адрес на экземпляр
# Point.set_coords(p1)
# # вызвали метод через класс и передали ссылку на экземпляр
# p1.set_coords1(3, 4)
# print(p1.get_coords())
