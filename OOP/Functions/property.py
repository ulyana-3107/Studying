class Person:

    def __init__(self, name, old):
        self.__name = name
        self.__old = old

    # для обращения к приватным свойствам класса создаются сеттеры и геттеры
    @property
    def old(self):
        return self.__old

    @old.setter
    def old(self, old):
        self.__old = old

    @old.deleter
    def old(self):
        del self.__old

    # Но есть проблема: придется прописывать геттеры и сеттеры для каждого приватного свойства, один из способов решения
    # проблемы: воспользоваться свойством объекта property. Для этого создадим еще один атрибут по имени old, который
    # будет являться объектом класса property. Куда мы передадим первым параметром ссылку на функцию getter, а вторым -
    # ccылку на функцию геттер.

    # old = property(get_old, set_old)
    # и это эквивалентно:
    # old = property()
    # old = old.setter(set_old)
    # old = old.getter(get_old)
    # И мы можем использовать эти декораторы чтобы сразу нужный нам метод превратить в объект-свойство класса property.
    # Для этого обязательно перед геттером прописывается @property

    # теперь с помощью каждого экземпляра класса мы можем обращаться к атрибуту old. Этот атрибут является объектом кла
    # сса Person. Данный объект так устроен, что при считывании данных командой (a = p.old) автоматически идет обращение
    # к методу get_old(), а при записи данных (p.old = 21) - автоматически вызывается метод set_old(). В результате мы с
    # помощью одного атрибута класса old мы можем считывать данные приватного свойства, или записывать данные в это же
    # приватное локальное свойство.

    # Если в классе задан атрибут свойства, то в первую очередь выбирается именно оно, даже если в экземпляре класса ес
    # ть свойства с таким-же именем. Это говорит о том, что приоритет у такого свойства выше чем у любого локального име
    # ни с таким свойством.

    # При вызове данных - сначала берется свойство из локальной видимости, а если оно не находится - то берется соответс
    # твующее свойство из пространства имен класса.

    # x = proerty(), x.setter(), x.getter(), x.deleter() - это все декораторы (в двух словах - это функции, которые рас
    # ширяют функционал какой-либо функции.


p = Person('Ulyana', 19)
p.old = 22
del p.old
print(p.old, p.__dict__)
