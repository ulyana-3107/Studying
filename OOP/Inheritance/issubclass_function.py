# Все пользовательские классы по умолчанию наследуются от базового класса object


class Geom:
    pass


# узнать имя объекта
print(Geom.__name__)

g = Geom()
# когда мы вызываем метод print от какого-либо экземплаяра то срабатывает маг.метод __str__ в классе object
print(g)

class Line(Geom):
    pass

# после создания дочернего класса Line цепочка наследования следующая:
# object -> Geom -> Line.
# т.е. указывая в качестве базового какой-либо класс непосредственное наследование от object уже не происходит

# так-же мы можем определять, является ли тот или иной класс подклассом другого класса с помощъю функции issubclass(),
# но эта функция работает только с классами, а не с их экземплярами
print(issubclass(Line, Geom))
# при проверке принадлежности объекта классу используется функция isinstance()
l = Line()
print(isinstance(l, Line), isinstance(l, Geom), isinstance(l, object))
# все стандартные типы данных в python так-же являются классами
print(issubclass(int, object))


class Vector(list):
    # pass
    def __str__(self):
        return ' ' .join(map(str, self))
# т.е. мы можем с помощъю создания нового класса наследуя базовые классы переопределить работу функций


v = Vector([1, 2, 3, 4, 5])
print(v)





