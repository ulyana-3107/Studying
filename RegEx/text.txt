Шаблоны, соответствующие одному символу

. - один любой символ, кроме новой строки \n.
\d - Любая цифра
\D - Любой символ, кроме цифры
\s - Любой пробельный символ (пробел, табуляция, конец строки и т.п.)
\S - Любой непробельный символ
\w - Любая буква (то, что может быть частью слова), а также цифры и _
\W - Любая не-буква, не-цифра, и не-подчеркивание
[..] - Один ищ символов в скобках, а также любой символ из диапазона a-b
[^..] - Любой символ, кроме перечисленных
\d~[0-9],
\D~[^0-9],
\w~[0-9a-zA-Zа-яА-Я],
\s~[\f\n\r\t\v]
[abc-], [-1] - если нужен минус, его нужно указать последним или первым
[*
[(+\\\]\t] - внутри скобок нужно экранировать только ] и \
\b - начало или конец слова. В отличие от предыдущих соответствует позиции, а не символу
\B - Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы


Квантификаторы(указание количества повторений)

{n} - ровно n повторений
{m, n} - от m до n повторений включительно
{m,} - не менее m повторений
{,n} - не более n повторений
?  {0, 1} - нуль или одно вхождение
{0,}  * - нуль или более
+  {1, } - одно или более
---
*?        По умолчанию квантифткаторы жадные - захватывают максимально возможное число
+?        символов. Добавление ? делает их ленивыми, они захватывают минимально возмож
??        ное число символов
{m, n}?
{,n}?
{m,}?
---
Задания:
1) Найдите все натуральные числа(возможно, окруженные буквами)
r"[a-zA-Zа-яА-Я]*[1-9]+[a-zA-Zа-яА-Я]*"
2) Найдите все 'слова', написанные капсом (то есть строго заглавными), возможно внутри
настоящего слова;
r[a-zа-яA-ZА-Я]*([A-ZА-Я])+[A-ZА-Яа-яa-z]*"
3) Найдите слова, в которых есть русская буква, а когда-нибудь за ней цифра;
"[А-Яа-я]+\d{1}"
4) Найдите все слова, начинающиеся с русской или латинской большой буквы (\b - граница слова);
r"\b[А-ЯA-Z][a-zA-Z]+"
5) Найдите слова, которые начинаются на гласную (\b - граница слова);
r"\b[уеыаоэюяиУЕЫАОЭЯИЮ][а-яА-Яё]*"
6) Найдите все натуральные числа, не находящиеся внутри или на границе слова;
r"\B[1-9]+\B"
7) Найдите строчки, в которых есть символ * ( . - это точно не конец строки!);
r"\B.*\*{1,}.*\B"
8) Найдите строчки, в которых есть открывающая и когда-нибудь потом закрывающая скобки;
r".*[(].*[)].*"
9) Выделите одним махом весь кусок оглавления (в конце примера, вместе с тегами);
r"\b.+\n\b"
10) Найдите пустые строчки;
r"\b\s+\n"


Функции для работы с регулярками и их смысл

re.search(pattern, string) - найдет в строке string первую строчку, подходящую под шаблон pattern;
re.fullmatch(pattern, string) - проверить, подходит ли строка string под шаблон pattern;
re.split(pattern, string) - аналог str.split(), только только разделение происходит по подстрокам, подходящим под шаблон
pattern;
re.findall(pattern, string) - найдет в строке string все непересекающиеся шаблоны pattern;
re.finditer(pattern, string) - итератор всем непересекающимся шаблонам pattern в строке string (выдаются match - объекты);
re.sub(pattern, repl, string, count=0) - заменит в строке string все непересекающиеся шаблоны pattern на repl;


Тонкости экранирования в питоне ('\\\\\foo')

Для того, чтобы не было нагромождения слешей, перед открывающей кавычкой нужно поставить символ r, что скажет питону:
не рассматривай \ как экранирующий символ (кроме случаев экранирования открывающей кавычки).


Использование дополнительных флагов в питоне

Каждой функции, перечисленной выше, можно дать дополнительный параметр flags, что несколько изменит режим работы
регулярок. В качестве значения нужно передать сумму выбранных констант.

re.ASCII - По умолчанию \w \W \s \S \d \D \b \B соответствуют все юникодные символы с соответствующим качеством. Напри
мер \d соответствуют не только арабские цифры, но и вот такие ٠١٢٣٤٥٦٧٨٩.  re.ASCII ускоряет работу, если все соответст
вия лежат внутри ASCII.
re.IGNORECASE - Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно.
re.MULTILINE - Специальные символы ^ и $ соответствуют началу и концу строки.
re.DOTALL - c этим флагом символ \n конца строки не подходит под точку. С этим флагом точка - вообще любой символ.


Скобочные группы (?:...) и перечисления |

Перечисления (операция 'ИЛИ')

Чтобы проверить, удовлетворяет ли строка хотя бы одному из шаблонов, можно воспользоваться аналогом оператора or, которы
й записывается с помощью символа |. Так, некоторая строка подходит к регулярному выражению A|B тогда и только тогда, ког
да она подходит хотя бы к одному из регулярных выражений A или B.

Скобочные группы (группировка плюс квантификаторы)

Зачастую шаблон состоит из нескольких повторяющихся групп. Так, MAC-адрес сетевого устройства обычно записывается как
шесть групп из двух шестнадцатиричных цифр, разделенных символами - или :. Например, 01:23:45:67:ab. Каждый отдельный
символ можно задать как [0-9a-fA-F], и можно весь шаблон записать так: [0-9a-fA-F]{2}[-:][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}
[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}.
Ситуация становится гораздо сложнее, когда количество групп заранее не зафиксировано. Чтобы разрешить эту проблему в син
таксисе регулярных выражений есть группировка (?:...). Можно писать круглые скобки и без значков ?:, одноко от этого у
группировки значительно меняется смысл, регулярка начинает работать гораздо медленнее. Итак, если REGEXP - шаблон, то
(?:REGEXP) - эквивалентный ему шаблон. Разница только в том, что теперь к (?:REGEXP) можно применять квантификаторы, ука
зывая, сколько именно раз должна повториться группа. Например, шаблон для поиска MAC-адреса, можно записать так:
[0-9a-fA-F]{2}(?:[:-][0-9a-fA-F){5}


Скобки плюс перечисления

Также скобки (?:...) позволяют локализовать часть шаблона, внутри которого происходит перечисление. Например, шаблон
(?:он|тот) (?:шел|плыл) соответствует каждой из строк 'он шел', 'он плыл', 'тот шел', 'тот плыл'.


Группирующие скобки (...) и match-объекты в питоне

Match-объекты

Если функции re.search, re.fullmatch не находят соответствие шаблону в строке, то они возвращают None, функция
re.finditer не выдает ничего. Однако если соответствие найдено, то возвращается match-объект. Эта штука содержит в себе
кучу полезной информации о соответствии шаблону. Полный набор атрибутов можно посмотреть в документации, а здесь приве
дем самое полезное.

match[0], match.group() - Подстрока, соответствующая шаблону.
match.start() - Индекс в исходной строке, с которого идет найденная подстрока.
match.end() - Индекс в исходной строке, который следует сразу за найденной подстрокой.


Группирующие скобки (...)

Если в шаблоне регулярного выражения встречаются скобки (...) без ?:, то они становятся группирующими. В match-объекте,
который возвращает re.search, re.fullmatch и re.finditer, по каждой такой группе можно получить ту же информацию, что и
по всему шаблону. А именно часть подстроки, которая соответствует (...), а также индексы начала и окончания в исходной
строке. Достаточно часто это бывает полезно.


Тонкости со скобками и нумерацией групп.

Если к группирующим скобкам применен квантификатор (то есть указано число повторений), то подгруппа в match-объекте бу
дет создана только для последнего соответствия.
Внутри группирующих скобок могут быть и другие группирующие скобки. В этом случае их нумерация производится в соответст
вии с номером появления открывающей скобки в шаблоне.


Группы и re.split

Если в шаблоне нет группирующих скобок, то re.split работает очень похожим образом на str.split. А вот если группирующие
скобки в шаблоне есть, то между каждыми разрезанными строками будут все соответствия каждой из подгрупп.


Использование групп при заменах

Использование групп добавляет замене (re.sub работает не только в питоне, а почти везде) очень удобную возможность: в ша
блоне для замены можно ссылаться на соответствующую группу при помощи \1, \2, \3, ... . Например, если нужно даты из неу
добного формата ММ/ДД/ГГГГ перевести в удобный ДД.ММ.ГГГГ, то можно использовать такую регулярку: re.sub(r'(\d\d)/(\d\d)
/(\d{4})', r'\2.\1.\3'


Замена с обработкой шаблона функцией в питоне

Еще одна питоновская фича для регулярных выражений: в функции re.sub вместо текста для замены можно передать функцию,
которая будет получать на вход match-объект и должна возвращать строку, на которую и будет произведена замена. Это позво
ляет не писать ад в шаблоне для замены, а использовать удобную функцию. Например, 'зацензурим' все слова, начинающиеся
на букву 'Х'(в отдельном скрипте).


Шаблоны, соответствующие не конкретному тексту, а позиции.

Отдельные части регулярного выражения могут соответствовать не части текста, а позиции в этом тексте. То есть такому шаб
лону соответствует не подстрока, а некоторая позиция в тексте, как бы "между" буквами.


Простые шаблоны, соответствующие позиции

Для определенности строку, в которой мы ищем шаблон будем называть всем текстом. Каждую строчку всего текста (то есть
каждый максимальный кусок без символов конца строки) будем называть строчкой текста.

^ Начало всего текста или начало строчки текста, если flag=re.MULTILINE
$ Конец всего текста или конец строчки текста, если flag=re.MULTILINE
\A Строго начало всего текста
\Z Строго конец всего текста
\b Начало или конец слова
\B Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы


Сложные шаблоны, соответствующие позиции (lookaround и Co)

Следующие шаблоны применяются в основном в тех случаях, когда нужно уточнить, что должно идти непосредственно перед или
после шаблона, но при этом не включать найденное в match-объект

(?=...) lookahead assertion, соответствует каждой позиции, сразу после которой начинается соответствие шаблону...
(?!...) negative lookahead assertion, соответствует каждой позиции, сразу после которой НЕ может начинаться шаблон...
(?<=...) positive lookbehind assertion, соответствует каждой позиции, которой может заканчиваться шаблон...
(?<!...) negative lookbehind assertion, соответствует каждой позиции, которой НЕ может заканчиваться шаблон...

Примеры:
(?<!\d)\d(?!\d) Цифра, окруженная нецифрами
(?<=#START#).*?(?=#END#) Текст от #START# до #END#
\d+(?=_(?!_)) Цифра, после которой идет ровно одно подчеркивание
^(?:(?!boo).)*?$ Строка, в которой нет boo (то есть нет такого символа, перед которым есть boo)
^(?:(?!boo)(?!foo).)*?$ Строка, в которой нет ни boo, ни foo


Скобочные группы (группировка плюс квантификаторы)

Зачастую шаблон состоит из нескольких повторяющихся групп. Так, MAC-адрес сетевого устройства обычно записывается как ше
сть групп из двух шестнадцитиричных цифр, разделенных символами - или :.
Ситуация становится гораздо сложнее, когда количество групп заранее не зафиксировано.
Чтобы разрешить эту проблему в синтаксисе регулярных выражений есть группировка (?:...). Можно писать круглые скобки и
без значков ?:, однако от этого у группировки значительно меняется смысл, регулярка начинает работать гораздо медленнее.
Если Regexp - шаблон, то (?: Regexp) - эквивалентный ему шаблон. Разница только в том, что теперь к шаблону, находящему
ся в скобочной группе те (?: Regexp) можно применять квантификаторы, указывая, сколько именно раз должна примениться гру
ппа. Например, шаблон для поиска MAC-адреса, можно записать так:
[0-9a-fA-F]{2}(?:[:-][0-9A-Fa-f]{2}){5}


Если в шаблоне встречаются скобки (...) и они без ?: то такие скобки становятся группирующими.
Если к группирующим скобкам применен квантификатор (тоесть указано число повторений), то подгруппа в match-объекте будет
создана только для последнего соответствия.
Внутри группирующих скобок могут быть и другие группирующие скобки. В таком случае нумерация производится в соответствии
с номером появления открывающей скобки.
Если в шаблоне есть группирующие скобки, то в match-объекте вместо списка найденных подстрок будет список кортежей, в ка
ждом из которых только соответствие каждой группе. Это не всегда происходит по плану, поэтому в таком случае нужно испо
льзовать негруппирующие скобки (?:...).


Простые шаблоны, соответствующие позиции

^ начало строки или всего текста
$ конец строки или всего текста
\A строго начало текста
\Z строго конец текста
\b начало или конец слова
\B не граница слова


Сложные шаблоны, соответствующие позиции

Следующие шаблоны применяются в основном в тех случаях, когда нужно уточнить, что должно идти непосредственно перед или
после шаблона, но не должно включать найденное в match-объект.

(?=...) lookahead assertion - соответствует позиции, сразу после которой начинается соответствие шаблону
(?!...) negative lookahead assertion - соответствует позиции, сразу после которой НЕ может идти соответствие шаблону
(?<=...) positive lookbehind assertion - соответствует каждой позиции, которой может заканчиваться шаблон... Длина шабло
на должна быть фиксированной
(?<!...) negative lookbehind assertion - соответствует каждой позиции, которой НЕ может заканчиваться шаблон.

